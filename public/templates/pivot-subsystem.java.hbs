package frc.robot.subsystems;

import edu.wpi.first.epilogue.Logged;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.simulation.SingleJointedArmSim;
import edu.wpi.first.math.controller.ArmFeedforward;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.wpilibj.RobotController;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj.simulation.BatterySim;
import edu.wpi.first.wpilibj.simulation.RoboRioSim;
import static edu.wpi.first.units.Units.Rotations;
import static edu.wpi.first.units.Units.RotationsPerSecond;
import static edu.wpi.first.units.Units.Radians;
import static edu.wpi.first.units.Units.RadiansPerSecond;
{{#if isSparkController}}
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.wpilibj.Notifier;
import java.util.function.DoubleSupplier;
{{/if}}

{{{motorControllerImports}}}

/**
* {{motorControllerType}} ile {{motorType}} motor kullanan Pivot Alt Sistemi
*/
@Logged(name = "{{ntKey}}")
public class {{subsystemName}} extends SubsystemBase {
// Sabit değerler
  private final DCMotor dcMotor = {{{dcMotorType}}};
private final int canID = {{canId}};
private final double gearRatio = {{gearRatio}};
  private final double kP = {{pidValues.kP}};
  private final double kI = {{pidValues.kI}};
  private final double kD = {{pidValues.kD}};
  private final double kS = {{kS}};
  private final double kV = {{kV}};
  private final double kA = {{kA}};
  private final double kG = 0; // Kullanılmayan Pivot için
private final double maxVelocity = {{maxVelocity}}; // radyan/saniye
private final double maxAcceleration = {{maxAcceleration}}; // radyan/saniye²
private final boolean brakeMode = {{brakeMode}};
 {{#if enableSoftLimits}}
 private final double forwardSoftLimit = {{forwardSoftLimit}}; // Maksimum açı (radyan)
 private final double reverseSoftLimit = {{reverseSoftLimit}}; // Minimum açı (radyan)
 {{/if}}
 private final boolean enableStatorLimit = {{enableStatorLimit}};
 private final double statorCurrentLimit = {{statorCurrentLimit}};
 private final boolean enableSupplyLimit = {{enableSupplyLimit}};
 private final double supplyCurrentLimit = {{supplyCurrentLimit}};

// İleri besleme
private final ArmFeedforward feedforward = new ArmFeedforward(
  kS, // kS
  0, // kG - Pivot için gravitasyon kompenzasyonu gerekmez
  kV, // kV
  kA  // kA
);

// Motor kontrolcü
{{{motorControllerDeclaration}}}

{{#if isSparkController}}
// Kontrol modu
private enum ControlMode {
  OPEN_LOOP,
  POSITION,
  VELOCITY
}
private ControlMode currentControlMode = ControlMode.OPEN_LOOP;
private double targetPosition = 0.0;
private double targetVelocity = 0.0;

// Profiled PID Controller
private ProfiledPIDController profiledPIDController;
private TrapezoidProfile.Constraints constraints;
private Notifier controlLoop;
private final double CONTROL_LOOP_FREQUENCY = 100.0; // Hz
{{/if}}

// Simülasyon
private final SingleJointedArmSim pivotSim;

/**
 * Yeni bir pivot alt sistemi oluşturur
 */
public {{subsystemName}}() {
  // Motor kontrolcüsünü başlat
  {{{motorControllerInitialization}}}

  
  // Simülasyonu başlat
  pivotSim = new SingleJointedArmSim(
    dcMotor, // Motor tipi
    gearRatio,
    0.01, // Atalet momenti - Pivot parametreleri olmadığı için küçük değer
    0.1, // Kol uzunluğu (m) - Pivot parametreleri olmadığı için küçük değer
    Units.degreesToRadians(-90), // Minimum açı (radyan)
    Units.degreesToRadians(90), // Maksimum açı (radyan)
    false, // Yerçekimi simülesi - Pivot için yerçekimi devre dışı
    Units.degreesToRadians(0) // Başlangıç pozisyonu (radyan)
  );

  {{#if isSparkController}}
  // ProfiledPIDController'ı başlat
  // Kısıtlamalar için radyandan rotasyona dönüştür
  double maxVelocityRotations = maxVelocity / (2.0 * Math.PI);
  double maxAccelerationRotations = maxAcceleration / (2.0 * Math.PI);
  
  constraints = new TrapezoidProfile.Constraints(maxVelocityRotations, maxAccelerationRotations);
  profiledPIDController = new ProfiledPIDController(kP, kI, kD, constraints);
  
  // Notifier kullanarak ayrı bir thread'de kontrol döngüsünü başlatır
  controlLoop = new Notifier(this::controlLoopFn);
  controlLoop.startPeriodic(1.0 / CONTROL_LOOP_FREQUENCY);
  {{/if}}
}

{{#if isSparkController}}
/**
 * Sabit frekansta çalışan kontrol döngüsü
 * Bu; SparkMax ve SparkFlex kontrolcülerini ana robot döngüsü dışında, kapalı-döngü içinde yerine getirmek amacıyla kullanılır.
 */
private void controlLoopFn() {
  switch (currentControlMode) {
    case POSITION:
      double currentPos = getPosition();
      double output = profiledPIDController.calculate(currentPos, targetPosition);
      double velocity = profiledPIDController.getSetpoint().velocity;
      double feedforwardOutput = feedforward.calculate(0, velocity); // Pivot için gravitasyon kompenzasyonu gerekmez
      setVoltage(output + feedforwardOutput);
      break;
      
    case VELOCITY:
      double currentVel = getVelocity();
      double velOutput = profiledPIDController.calculate(currentVel, targetVelocity);
      double accel = profiledPIDController.getSetpoint().velocity - currentVel;
      double velFeedforwardOutput = feedforward.calculate(0, targetVelocity, accel); // Pivot için gravitasyon kompenzasyonu gerekmez
      
      // Birleşmiş PID çıkışını ve feedforward'ını motora uygular
      double velocityVoltage = velOutput + velFeedforwardOutput;
      motor.setVoltage(velocityVoltage);
      break;
      
    case OPEN_LOOP:
    default:
      // Açık döngü modunda bir şey yapma, voltaj doğrudan ayarlanır
      break;
  }
}

/**
 * Alt sistem kapatıldığında kaynakları temizleyin
 */
@Override
  public void close() {
     motor.close();
   
}
{{/if}}

/**
 * Simülasyon ve telemetriyi günceller
 */
@Override
public void periodic() {
  {{{motorControllerPeriodic}}}
}

/**
 * Simülasyonu günceller
 */
@Override
public void simulationPeriodic() {
  // Motor kontrolcüsünden simülasyona giriş voltajını ayarla
  // Not: Bu talonfx.getSimState().getMotorVoltage() olarak giriş olabilir.
  //pivotSim.setInput(dcMotor.getVoltage(dcMotor.getTorque(pivotSim.getCurrentDrawAmps()), pivotSim.getVelocityRadPerSec()));
  // pivotSim.setInput(getVoltage());
  // Motor kontrolcüsünden simülasyona giriş voltajını ayarla
   {{#if (or (eq motorControllerType 'TalonFX') (eq motorControllerType 'TalonFXS'))}}
   // TalonFX simülasyon girişi için motor voltajını kullanın
   pivotSim.setInput(motor.getSimState().getMotorVoltage());
   {{else}}
   // Diğer kontrolcüler için getVoltage() kullanır
   pivotSim.setInput(getVoltage());
   {{/if}}

  // Simülasyonu 20ms'de güncelle
  pivotSim.update(0.020);
  RoboRioSim.setVInVoltage(BatterySim.calculateDefaultBatteryLoadedVoltage(pivotSim.getCurrentDrawAmps()));

  double motorPosition = Radians.of(pivotSim.getAngleRads() * gearRatio).in(Rotations);
  double motorVelocity = RadiansPerSecond.of(pivotSim.getVelocityRadPerSec() * gearRatio).in(RotationsPerSecond);
  {{{motorControllerSimulationPeriodic}}}
}

/**
 * Rotasyonlarda mevcut konumu alır.
 * @return Rotasyonlardaki konum
 */
  {{#if logPosition}}
  @Logged(name = "Position/Rotations")
  {{/if}}
public double getPosition() {
  // Rotasyonlar
  {{{getPositionMethod}}}
}

{{#if (or (eq positionUnit 'Degrees') (eq positionUnit 'Radians'))}}
/**
 * Mevcut konumu {{positionUnit}} cinsinden alır.
 * @return {{positionUnit}} cinsinden konum
 */
  {{#if logPosition}}
  @Logged(name = "Position/{{positionUnit}}")
  {{/if}}
public double getPosition{{positionUnit}}() {
  {{#if (eq positionUnit 'Degrees')}}
  return getPosition() * 360;
  {{else}}
  return getPosition() * 2 * Math.PI;
  {{/if}}
}
{{/if}}


/**
 * Saniye başına dönüş sayısında mevcut hızı alın.
 * @return Saniye başına dönüş hızı
 */
  {{#if logVelocity}}
  @Logged(name = "Velocity")
  {{/if}}
public double getVelocity() {
  {{{getVelocityMethod}}}

}

/**
 * Mevcut uygulanan voltajı alır.
 * @return Uygulanan voltaj
 */
  {{#if logVoltage}}
  @Logged(name = "Voltage")
  {{/if}}
public double getVoltage() {
  {{{getVoltageMethod}}}
}

/**
 * Mevcut motor akımını alır.
 * @return Motor akımı (amper cinsinden)
 */
  {{#if logCurrent}}
  @Logged(name = "Current")
  {{/if}}
public double getCurrent() {
  {{{getCurrentMethod}}}
}

/**
 * Mevcut motor sıcaklığını alır.
 * @return Motor sıcaklığı (Celsius cinsinden)
 */
  {{#if logTemperature}}
  @Logged(name = "Temperature")
  {{/if}}
public double getTemperature() {
  {{{getTemperatureMethod}}}
}

/**
 * Pivot açısını ayarla.
 * @param angleDegrees Hedef açı (derece cinsinden)
 */
public void setAngle(double angleDegrees) {
  setAngle(angleDegrees, 0);
}

/**
 * Hızlanma ile pivot açısını ayarlayın.
 * @param angleDegrees Hedef açı (derece cinsinden)
 * @param acceleration İvme [radyan/saniye² cinsinden]
 */
public void setAngle(double angleDegrees, double acceleration) {
  // Dereceyi radyana, sonra rotasyona çevirir
  double angleRadians = Units.degreesToRadians(angleDegrees);
  double positionRotations = angleRadians / (2.0 * Math.PI);
  
  {{#if isSparkController}}
  // ProfiledPIDController kullanılır
  targetPosition = positionRotations;
  currentControlMode = ControlMode.POSITION;
  
  // İvme belirtilirse, kısıtlamaları günceller
  if (acceleration > 0) {
    double maxAccelRotations = acceleration / (2.0 * Math.PI);
    constraints = new TrapezoidProfile.Constraints(constraints.maxVelocity, maxAccelRotations);
    profiledPIDController.setConstraints(constraints);
  }
  {{else}}
  {{{setPositionMethod}}}
  {{/if}}
}

/**
 * Pivot açısal hızını ayarlar.
 * @param velocityDegPerSec Hedef hız (derece/saniye cinsinden)
 */
public void setVelocity(double velocityDegPerSec) {
  setVelocity(velocityDegPerSec, 0);
}

/**
 * Hızlanma ile pivot açısal hızını ayarlayın.
 * @param velocityDegPerSec Hedef hız (derece/saniye cinsinden)
 * @param acceleration İvme (derece/saniye² cinsinden)
 */
public void setVelocity(double velocityDegPerSec, double acceleration) {
  // Derece/saniye'yi rotasyon/saniye'ye dönüştür
  double velocityRadPerSec = Units.degreesToRadians(velocityDegPerSec);
  double velocityRotations = velocityRadPerSec / (2.0 * Math.PI);
  
  {{#if isSparkController}}
  // ProfiledPIDController kullanılır
  targetVelocity = velocityRotations;
  currentControlMode = ControlMode.VELOCITY;
  
  // İvme belirtilirse, kısıtlamaları günceller
  if (acceleration > 0) {
    double maxAccelRotations = Units.degreesToRadians(acceleration) / (2.0 * Math.PI);
    constraints = new TrapezoidProfile.Constraints(constraints.maxVelocity, maxAccelRotations);
    profiledPIDController.setConstraints(constraints);
  }
  
  // Hızı doğrudan motor kontrol cihazına da uygular
  // Bu, kontrol döngüsü onu iyileştirirken anında tepki verilmesini sağlar
  double ffVolts = feedforward.calculate(0, velocityRotations, 0); // Pivot için gravitasyon kompenzasyonu gerekmez
  motor.setVoltage(ffVolts);
  {{else}}
  {{{setVelocityMethod}}}
  {{/if}}
}

/**
 * Motor voltajını doğrudan ayarlayın.
 * @param voltage Uygulanacak voltaj
 */
public void setVoltage(double voltage) {
  {{#if isSparkController}}
  currentControlMode = ControlMode.OPEN_LOOP;
  {{/if}}
  {{{setVoltageMethod}}}
}

/**
 * Test için pivot simülasyonunu alır.
 * @return Pivot simülasyon modeli
 */
public SingleJointedArmSim getSimulation() {
  return pivotSim;
}

/**
 * Pivot'ı belirli bir açıya ayarlamak için bir komut oluşturur.
 * @param angleDegrees Hedef açı (derece cinsinden)
 * @return Pivot'ı belirtilen açıya ayarlayan bir komut
 */
public Command setAngleCommand(double angleDegrees) {
  return runOnce(() -> setAngle(angleDegrees));
}

/**
 * Pivot'ı belirli bir açıya profil ile hareket ettirmek için bir komut oluşturur.
 * @param angleDegrees Hedef açı (derece cinsinden)
 * @return Pivot'ı belirtilen açıya hareket ettirilmesi için bir komut
 */
public Command moveToAngleCommand(double angleDegrees) {
  return run(() -> {
    {{#if isSparkController}}
    // Sadece konumu ayarlayın ve profilli kontrolörün halletmesine izin verin.
    setAngle(angleDegrees);
    {{else}}
    double currentAngle = Units.radiansToDegrees(getPositionRadians());
    double error = angleDegrees - currentAngle;
    double velocityDegPerSec = Math.signum(error) * Math.min(Math.abs(error) * 2.0, Units.radiansToDegrees(maxVelocity));
    setVelocity(velocityDegPerSec);
    {{/if}}
  }).until(() -> {
    double currentAngle = Units.radiansToDegrees(getPositionRadians());
    return Math.abs(angleDegrees - currentAngle) < 2.0; // 2 derece tolerans
  }).finallyDo((interrupted) -> setVelocity(0));
}

/**
 * Pivot'ı durdurmak için bir komut oluşturur.
 * @return Pivot'ı durduran bir komut
 */
public Command stopCommand() {
  return runOnce(() -> setVelocity(0));
}

/**
 * Pivot'ı belirli bir hızda hareket ettirmek için bir komut oluşturur.
 * @param velocityDegPerSec Hedef hız (derece/saniye cinsinden)
 * @return Pivot'ı belirtilen hızda hareket ettiren bir komut
 */
public Command moveAtVelocityCommand(double velocityDegPerSec) {
  return run(() -> setVelocity(velocityDegPerSec));
}
}
