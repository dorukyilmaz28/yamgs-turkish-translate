package frc.robot.subsystems;

import edu.wpi.first.epilogue.Logged;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.simulation.SingleJointedArmSim;
import edu.wpi.first.math.controller.ArmFeedforward;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.wpilibj.RobotController;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj.simulation.BatterySim;
import edu.wpi.first.wpilibj.simulation.RoboRioSim;
import static edu.wpi.first.units.Units.Rotations;
import static edu.wpi.first.units.Units.RotationsPerSecond;
import static edu.wpi.first.units.Units.Radians;
import static edu.wpi.first.units.Units.RadiansPerSecond;
{{#if isSparkController}}
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.wpilibj.Notifier;
import java.util.function.DoubleSupplier;
{{/if}}

{{{motorControllerImports}}}

/**
* {{motorControllerType}} ile {{motorType}} motor kullanan Pivot Subsistemi
*/
@Logged(name = "{{ntKey}}")
public class {{subsystemName}} extends SubsystemBase {
// Sabit değerler
  private final DCMotor dcMotor = {{{dcMotorType}}};
private final int canID = {{canId}};
private final double gearRatio = {{gearRatio}};
  private final double kP = {{pidValues.kP}};
  private final double kI = {{pidValues.kI}};
  private final double kD = {{pidValues.kD}};
  private final double kS = {{kS}};
  private final double kV = {{kV}};
  private final double kA = {{kA}};
  private final double kG = 0; // Kullanılmayan Pivot için
private final double maxVelocity = {{maxVelocity}}; // radyan/saniye
private final double maxAcceleration = {{maxAcceleration}}; // radyan/saniye²
private final boolean brakeMode = {{brakeMode}};
 {{#if enableSoftLimits}}
 private final double forwardSoftLimit = {{forwardSoftLimit}}; // maximum radyan değeri için açı değeri
 private final double reverseSoftLimit = {{reverseSoftLimit}}; // minimum radyan değeri için açı değeri
 {{/if}}
 private final boolean enableStatorLimit = {{enableStatorLimit}};
 private final double statorCurrentLimit = {{statorCurrentLimit}};
 private final boolean enableSupplyLimit = {{enableSupplyLimit}};
 private final double supplyCurrentLimit = {{supplyCurrentLimit}};

// İleri besleme
private final ArmFeedforward feedforward = new ArmFeedforward(
  kS, // kS
  0, // kG - Pivot için gravitasyon kompenzasyonu gerekmez
  kV, // kV
  kA  // kA
);

// Motor kontrolcü
{{{motorControllerDeclaration}}}

{{#if isSparkController}}
// Kontrol modu
private enum ControlMode {
  OPEN_LOOP,
  POSITION,
  VELOCITY
}
private ControlMode currentControlMode = ControlMode.OPEN_LOOP;
private double targetPosition = 0.0;
private double targetVelocity = 0.0;

// Profiled PID Controller
private ProfiledPIDController profiledPIDController;
private TrapezoidProfile.Constraints constraints;
private Notifier controlLoop;
private final double CONTROL_LOOP_FREQUENCY = 100.0; // Hz
{{/if}}

// Simülasyon
private final SingleJointedArmSim pivotSim;

/**
 * Yeni bir Pivot Subsistemi oluşturur.
 */
public {{subsystemName}}() {
  // Motor kontrolcüsünü başlat
  {{{motorControllerInitialization}}}

  
  // Simülasyonu başlat
  pivotSim = new SingleJointedArmSim(
    dcMotor, // Motor tipi
    gearRatio,
    0.01, // Kolun moment of inertia - Kol parametreleri olmadığı için küçük değer
    0.1, // Kol uzunluğu (m) - Kol parametreleri olmadığı için küçük değer
    Units.degreesToRadians(-90), // Minimum açı (radyan)
    Units.degreesToRadians(90), // Maksimum açı (radyan)
    false, // Yerçekimi simülesi - Pivot için yerçekimi devre dışı
    Units.degreesToRadians(0) // Başlangıç pozisyonu (radyan)
  );

  {{#if isSparkController}}
  // Profillenmiş PID kontrolcüsünü başlat
  // Radyanları dönüştürerek kısıtlamalar için
  double maxVelocityRotations = maxVelocity / (2.0 * Math.PI);
  double maxAccelerationRotations = maxAcceleration / (2.0 * Math.PI);
  
  constraints = new TrapezoidProfile.Constraints(maxVelocityRotations, maxAccelerationRotations);
  profiledPIDController = new ProfiledPIDController(kP, kI, kD, constraints);
  
  // Notifier kullanarak ayrı bir thread'de kontrol döngüsünü başlat
  controlLoop = new Notifier(this::controlLoopFn);
  controlLoop.startPeriodic(1.0 / CONTROL_LOOP_FREQUENCY);
  {{/if}}
}

{{#if isSparkController}}
/**
 * Sabit frekansta çalışan kontrol döngüsü fonksiyonu.
 * SparkMAX ve SparkFlex kontrolcülerini uygulamak için kullanılır.
 * Ana robot döngüsü dışında kapalı döngü kontrolü.
 */
private void controlLoopFn() {
  switch (currentControlMode) {
    case POSITION:
      double currentPos = getPosition();
      double output = profiledPIDController.calculate(currentPos, targetPosition);
      double velocity = profiledPIDController.getSetpoint().velocity;
      double feedforwardOutput = feedforward.calculate(0, velocity); // Pivot için gravitasyon kompenzasyonu gerekmez
      setVoltage(output + feedforwardOutput);
      break;
      
    case VELOCITY:
      double currentVel = getVelocity();
      double velOutput = profiledPIDController.calculate(currentVel, targetVelocity);
      double accel = profiledPIDController.getSetpoint().velocity - currentVel;
      double velFeedforwardOutput = feedforward.calculate(0, targetVelocity, accel); // Pivot için gravitasyon kompenzasyonu gerekmez
      
      // Birleştirilmiş PID çıkışını ve ileri beslemeyi motora uygulaması.
      double velocityVoltage = velOutput + velFeedforwardOutput;
      motor.setVoltage(velocityVoltage);
      break;
      
    case OPEN_LOOP:
    default:
      // Hiçbir şey yapma, voltaj doğrudan ayarlanır.
      break;
  }
}

/**
 * Alt sistem yok edildiğinde kaynakları temizleyin.
 */
@Override
  public void close() {
     motor.close();
   
}
{{/if}}

/**
 * Simülasyon ve telemetriyi güncelle.
 */
@Override
public void periodic() {
  {{{motorControllerPeriodic}}}
}

/**
 * Simülasyonu güncelle.
 */
@Override
public void simulationPeriodic() {
  // Motor kontrolcüsünden simülasyona giriş voltajını ayarla
  // Not: Bu talonfx.getSimState().getMotorVoltage() olarak giriş olabilir.
  //pivotSim.setInput(dcMotor.getVoltage(dcMotor.getTorque(pivotSim.getCurrentDrawAmps()), pivotSim.getVelocityRadPerSec()));
  // pivotSim.setInput(getVoltage());
  // Motor kontrolcüsünden simülasyona giriş voltajını ayarla
   {{#if (or (eq motorControllerType 'TalonFX') (eq motorControllerType 'TalonFXS'))}}
   // Use motor voltage for TalonFX simulation input
   pivotSim.setInput(motor.getSimState().getMotorVoltage());
   {{else}}
   // Use getVoltage() for other controllers
   pivotSim.setInput(getVoltage());
   {{/if}}

  // Simülasyonu 20ms'de güncelle
  pivotSim.update(0.020);
  RoboRioSim.setVInVoltage(BatterySim.calculateDefaultBatteryLoadedVoltage(pivotSim.getCurrentDrawAmps()));

  double motorPosition = Radians.of(armSim.getAngleRads() * gearRatio).in(Rotations);
  double motorVelocity = RadiansPerSecond.of(armSim.getVelocityRadPerSec() * gearRatio).in(RotationsPerSecond);
  {{{motorControllerSimulationPeriodic}}}
}

/**
 * Get the current position in Rotations.
 * @return Rotasyonlardaki Konum
 */
  {{#if logPosition}}
  @Logged(name = "Position/Rotations")
  {{/if}}
public double getPosition() {
  // Rotations
  {{{getPositionMethod}}}
}

{{#if (or (eq positionUnit 'Degrees') (eq positionUnit 'Radians'))}}
/**
 * Şuanki pozisyonu {{positionUnit}} alır.
 * @return {{positionUnit}} cinsinden konum.
 */
  {{#if logPosition}}
  @Logged(name = "Position/{{positionUnit}}")
  {{/if}}
public double getPosition{{positionUnit}}() {
  {{#if (eq positionUnit 'Degrees')}}
  return getPosition() * 360;
  {{else}}
  return getPosition() * 2 * Math.PI;
  {{/if}}
}
{{/if}}


/**
 * Saniye başına dönüş sayısında mevcut hızı alın.
 * @return Saniye başına dönüş hızı
 */
  {{#if logVelocity}}
  @Logged(name = "Velocity")
  {{/if}}
public double getVelocity() {
  {{{getVelocityMethod}}}

}

/**
 * Mevcut uygulanan voltajı alın.
 * @return Applied voltage
 */
  {{#if logVoltage}}
  @Logged(name = "Voltage")
  {{/if}}
public double getVoltage() {
  {{{getVoltageMethod}}}
}

/**
 * Mevcut motor akımını alın.
 * @return Motor current in amps
 */
  {{#if logCurrent}}
  @Logged(name = "Current")
  {{/if}}
public double getCurrent() {
  {{{getCurrentMethod}}}
}

/**
 * Mevcut motor sıcaklığını alın.
 * @return Motor temperature in Celsius
 */
  {{#if logTemperature}}
  @Logged(name = "Temperature")
  {{/if}}
public double getTemperature() {
  {{{getTemperatureMethod}}}
}

/**
 * Pivot açısını ayarla.
 * @param angleDegrees Hedef açı (derece cinsinden)
 */
public void setAngle(double angleDegrees) {
  setAngle(angleDegrees, 0);
}

/**
 * Hızlanma ile pivot açısını ayarlayın.
 * @param angleDegrees Hedef açı (derece cinsinden)
 * @param acceleration İvme [radyan/saniye² cinsinden]
 */
public void setAngle(double angleDegrees, double acceleration) {
  // Dereceleri dönüştürerek dönüş sayısına çevirir.
  double angleRadians = Units.degreesToRadians(angleDegrees);
  double positionRotations = angleRadians / (2.0 * Math.PI);
  
  {{#if isSparkController}}
  // Profillenmiş PID kontrolcüsünü kullanır
  targetPosition = positionRotations;
  currentControlMode = ControlMode.POSITION;
  
  // İvme belirtilirse, kısıtlamaları günceller
  if (acceleration > 0) {
    double maxAccelRotations = acceleration / (2.0 * Math.PI);
    constraints = new TrapezoidProfile.Constraints(constraints.maxVelocity, maxAccelRotations);
    profiledPIDController.setConstraints(constraints);
  }
  {{else}}
  {{{setPositionMethod}}}
  {{/if}}
}

/**
 * Set pivot angular velocity.
 * @param velocityDegPerSec Hedef hız (derece/saniye cinsinden)
 */
public void setVelocity(double velocityDegPerSec) {
  setVelocity(velocityDegPerSec, 0);
}

/**
 * Hızlanma ile pivot açısal hızını ayarlayın.
 * @param velocityDegPerSec Hedef hız (derece/saniye cinsinden)
 * @param acceleration İvme (derece/saniye² cinsinden)
 */
public void setVelocity(double velocityDegPerSec, double acceleration) {
  // Convert degrees/sec to rotations/sec
  double velocityRadPerSec = Units.degreesToRadians(velocityDegPerSec);
  double velocityRotations = velocityRadPerSec / (2.0 * Math.PI);
  
  {{#if isSparkController}}
  // Use the ProfiledPIDController
  targetVelocity = velocityRotations;
  currentControlMode = ControlMode.VELOCITY;
  
  // İvme belirtilirse, kısıtlamaları günceller
  if (acceleration > 0) {
    double maxAccelRotations = Units.degreesToRadians(acceleration) / (2.0 * Math.PI);
    constraints = new TrapezoidProfile.Constraints(constraints.maxVelocity, maxAccelRotations);
    profiledPIDController.setConstraints(constraints);
  }
  
  // Hızı doğrudan motor kontrol cihazına da uygular
  // This ensures immediate response while the control loop refines it
  double ffVolts = feedforward.calculate(0, velocityRotations, 0); // Pivot için gravitasyon kompenzasyonu gerekmez
  motor.setVoltage(ffVolts);
  {{else}}
  {{{setVelocityMethod}}}
  {{/if}}
}

/**
 * Motor voltajını doğrudan ayarlayın.
 * @param voltage Uygulanacak voltaj
 */
public void setVoltage(double voltage) {
  {{#if isSparkController}}
  currentControlMode = ControlMode.OPEN_LOOP;
  {{/if}}
  {{{setVoltageMethod}}}
}

/**
 * Get the pivot simulation for testing.
 * @return Pivot simülasyon modeli
 */
public SingleJointedpivotSim getSimulation() {
  return pivotSim;
}

/**
 * Pivot'ı belirli bir açıya ayarlamak için bir komut oluşturur.
 * @param angleDegrees Hedef açı (derece cinsinden)
 * @return Pivot'ı belirtilen açıya ayarlayan bir komut
 */
public Command setAngleCommand(double angleDegrees) {
  return runOnce(() -> setAngle(angleDegrees));
}

/**
 * Pivot'ı belirli bir açıya profil ile hareket ettirmek için bir komut oluşturur.
 * @param angleDegrees Hedef açı (derece cinsinden)
 * @return Pivot'ı belirtilen açıya hareket ettirilmesi için bir komut
 */
public Command moveToAngleCommand(double angleDegrees) {
  return run(() -> {
    {{#if isSparkController}}
    // Sadece konumu ayarlayın ve profilli kontrolörün halletmesine izin verin.
    setAngle(angleDegrees);
    {{else}}
    double currentAngle = Units.radiansToDegrees(getPositionRadians());
    double error = angleDegrees - currentAngle;
    double velocityDegPerSec = Math.signum(error) * Math.min(Math.abs(error) * 2.0, Units.radiansToDegrees(maxVelocity));
    setVelocity(velocityDegPerSec);
    {{/if}}
  }).until(() -> {
    double currentAngle = Units.radiansToDegrees(getPositionRadians());
    return Math.abs(angleDegrees - currentAngle) < 2.0; // 2 degree tolerance
  }).finallyDo((interrupted) -> setVelocity(0));
}

/**
 * Pivot'ı durdurmak için bir komut oluşturur.
 * @return Pivot'ı durduran bir komut
 */
public Command stopCommand() {
  return runOnce(() -> setVelocity(0));
}

/**
 * Pivot'ı belirli bir hızda hareket ettirmek için bir komut oluşturur.
 * @param velocityDegPerSec Hedef hız (derece/saniye cinsinden)
 * @return Pivot'ı belirtilen hızda hareket ettiren bir komut
 */
public Command moveAtVelocityCommand(double velocityDegPerSec) {
  return run(() -> setVelocity(velocityDegPerSec));
}
}
